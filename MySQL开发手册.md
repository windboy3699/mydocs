# MySQL开发手册

## 选择合适的数据类型

**更小的通常更好**
* 选择你认为不会超过的最小范围
* VARCHAR需要1或2个额外字节存储字符串长度，超过255使用2个字节，VARCHAR(256)比VARCHAR(255)要多1个字节
* 固定长度的字段使用CHAR类型
* 整型通常是标识列最好的选择

**简单就好**
* 整型比字符串操作代价更低
* 使用整型存储IP地址，MySQL提供INET_ATON和INET_NTOA函数来转换
* TIMESTAMP只使用DATATIME一半的存储空间，根据时区的变化具有自动更新能力，但范围只能1970-2038年，不推荐用整型存储时间戳
* ENUM要慎用，在插入、更新、索引、排序、迁移的时候可能会产生问题，添加删除字段会ALTER TABLE
* 关联表关联字段使用相同的类型，避免字符类型转换

**尽量避免使用Null**

可为Null的列索引会使用更多的存储空间，每个索引记录需要一个额外的字节。  
可为Null的列MySQL需要特殊处理，使得索引、索引统计、值的比较更多复杂。  
有个例外，当使用Innodb的列很多值为Null,少数为非Null的时候有很好的效率，但不适用MyISAM。

## 创建合适的索引

**独立的列**

“独立的列”是指查询的时候索引列不能是表达式的一部分，也不能是函数的参数。

**哈希索引**

新建一个字段来存放某个较长字段的哈希值，通过查询哈希值来查询原来的字段，只适用全值匹配

**多列索引**

假如对name,sex,age三个字段做组合索引，如果只需要查询name和age就无法使用索引，但是sex的值比较固定只2个值，这个时候可以在查询条件中新增sex in ("m","f")，让MySQL来选择该索引，这样并不会过滤掉任何行。如果in()的值太多就不适合了。另外，将需要做范围查询的age放在索引的最后，使优化器能尽可能多的使用索引列。多列索引还要选择合适的索引列顺序。

**覆盖索引**

如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。能避免返回原表获取数据行。

**优化排序**

假如有个查询select cols from user where sex = "m" order by sort desc limit 10，符合条件的结果非常多再做排序的话会很耗时，这时可以添加(sex,sort)的组合索引，利用索引排序。  
另外，在分页的时候如果页数很大，MySQL需要扫描很多丢弃的数据，这时可以使用延迟关联，通过使用覆盖索引返回需要的主键，再根据主键从原表获取需要的行，减少扫描后又丢弃的数据。  
下面这个查询显示了利用(sex,sort)组合索引进行排序和分页（id为主键）：  
select col1,col2 from user join (select id from user where sex = "m" order by sort desc limit 10000,10) as x on  user.id = x.id

## 特定案例优化
