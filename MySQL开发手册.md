# MySQL开发手册

## 索引

* <a href="#p1">选择合适的数据类型</a>
* <a href="#p2">创建合适的索引</a>
* <a href="#p3">EXPLAIN返回值说明</a>
* <a href="#p4">特定案例优化</a>
    * <a href="#p41">分页设计</a>

<p></p>
<p></p>
<p></p>

## <a name="p1">选择合适的数据类型</a>

**更小的通常更好**
* 选择你认为不会超过的最小范围
* VARCHAR需要1或2个额外字节存储字符串长度，超过255使用2个字节，VARCHAR(256)比VARCHAR(255)要多1个字节
* 固定长度的字段使用CHAR类型
* 整型通常是标识列最好的选择

**简单就好**
* 整型比字符串操作代价更低
* 使用整型存储IP地址，MySQL提供INET_ATON和INET_NTOA函数来转换
* TIMESTAMP只使用DATATIME一半的存储空间，根据时区的变化具有自动更新能力，但范围只能1970-2038年，不推荐用整型存储时间戳
* ENUM要慎用，在插入、更新、索引、排序、迁移的时候可能会产生问题，添加删除字段会ALTER TABLE
* 关联表关联字段使用相同的类型，避免字符类型转换

**尽量避免使用Null**

可为Null的列索引会使用更多的存储空间，每个索引记录需要一个额外的字节。  
可为Null的列MySQL需要特殊处理，使得索引、索引统计、值的比较更多复杂。  
有个例外，当使用Innodb的列很多值为Null,少数为非Null的时候有很好的效率，但不适用MyISAM。

## <a name="p2">创建合适的索引</a>

**独立的列**

“独立的列”是指查询的时候索引列不能是表达式的一部分，也不能是函数的参数。

**哈希索引**

新建一个字段来存放某个较长字段的哈希值，通过查询哈希值来查询原来的字段，只适用全值匹配

**多列索引**

假如对name,sex,age三个字段做组合索引，如果只需要查询name和age就无法使用索引，但是sex的值比较固定只2个值，这个时候可以在查询条件中新增sex in ("m","f")，让MySQL来选择该索引，这样并不会过滤掉任何行。如果in()的值太多就不适合了。另外，将需要做范围查询的age放在索引的最后，使优化器能尽可能多的使用索引列。多列索引还要选择合适的索引列顺序。

**覆盖索引**

如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。能避免返回原表获取数据行。

**优化排序**

假如有个查询select cols from user where sex = "m" order by sort desc limit 10，符合条件的结果非常多再做排序的话会很耗时，这时可以添加(sex,sort)的组合索引，利用索引排序。  
另外，在分页的时候如果页数很大，MySQL需要扫描很多丢弃的数据，这时可以使用延迟关联，通过使用覆盖索引返回需要的主键，再根据主键从原表获取需要的行，减少扫描后又丢弃的数据。  
下面这个查询显示了利用(sex,sort)组合索引进行排序和分页（id为主键）：  
select col1,col2 from user join (select id from user where sex = "m" order by sort desc limit 10000,10) as x on  user.id = x.id

## <a name="p3">EXPLAIN返回值说明</a>

**id**  
编号，一条SQL语句可能包含多个子查询。id相同时，执行顺序由上到下。

**select_type**  
简单查询或复杂查询，SIMPLE值意味着不包含子查询或UNION，其它就是复杂查询

**table**  
显示对应行访问的表或别名

**type**

常用的类型有：ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）

* ALL：全表扫描
* index：跟全表扫描一样，只是扫描表时按索引次序进行而不是行。优点是避免了排序，缺点是按随机次序访问行，开销会非常大。如果在Extra列中看到"Using index"，说明MySQL正在使用覆盖索引，它只扫描索引数据，而不是按索引次序的每一行，它比按索引次序全表扫描的开销要少很多。
* range：范围扫描就是一个有限制到索引扫描，这比全表扫描好一些，因为它用不着遍历全部索引。像BETWEEN、WHERE col >、IN()、OR都会显示为范围扫描。此类扫描的开销跟索引类型相当。
* ref：这是一种索引访问，它返回所有匹配某个单个值的行，它可能会找到多个符合条件的行，因此，它是查找和扫描的混合体。此类索引访问只有当使用非唯一索引才会发生。
* eq_ref：使用这种索引查找，MySQL知道最多只返回一条符合条件的记录。这种访问方法可以在使用主键或者唯一性索引上查找时看到。简单来说，就是多表连接中使用主键或者唯一索引作为关联条件。
* const,system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下使用system。
* NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。

**possible_keys**  
这一列显示了查询可以使用哪些索引，这是基于查询访问的列和使用的比较操作符来判断的。这个列表是在优化过程的早期创建的，因此，有些罗列出来的索引可能对于后续优化过程是没用的。

**key**  
这一列显示了MySQL决定采用哪个索引来优化对该表的访问。如果该索引没有出现在possible_keys列中，那么MySQL选用它是出于另外的原因，例如，它可能选择了一个覆盖索引，哪怕没有WHERE子句。

**key_len**  
该列显示MySQL在索引里使用的字节数。如果MySQL正在使用的只是索引里的某些列，那么就可以用这个值来算出具体是哪些列。key_len通过查找表的定义而被计算出，而不是表中的数据。

**ref**  
这一列显示了之前的表在key列记录的索引中查找值所用的列或常量。

**row**  
这一列是MySQL估计为了找到所需的行而读取的行数。是个估值，不一定精确。

**filtered**  
它显示的是针对表里符合某个条件的记录数的百分比所做的一个悲观估算。

**Extra**  
这一列显示的是不适合在其他列显示的额外信息。

* Using index：此值表示MySQL将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了。
* Using where：这意味着MySQL服务器将在存储引擎检索后再进行过滤。许多WHERE条件里涉及索引中的列，当它读取索引时，就能被存储引擎检验，因此不是所有带WHERE子句的查询都会显示"Using where"。有时，"Using where"的出现就是一个暗示：查询可受益于不同的索引。
* Using temporary：这意味着MySQL在对查询结果排序时会使用一个临时表。
* Using filesort：这意味着MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。
* Range checked for each record(index map:N)：这个值意味着没有好用的索引，新的索引将在联接的每一行上重新估算。N是显示在possible_keys列中索引的位图，并且是冗余的。

## <a name="p4">特定案例优化</a>

### <a name="p41">分页设计</a>

假设有个视频库，有如下分类：  
类型：全部 | 偶像爱情 | 古装历史 | 都市生活 | 历险科幻 | 真人动漫  
地区：全部 | 内地 | 美国 | 英国 | 韩国 | 泰国  
年份：全部 | 2020 | 2019 | 2018 | 2017 | 2016  
排序：最新 | 最热 | 好评

